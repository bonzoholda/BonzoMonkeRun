<!DOCTYPE html>
<html>
<head>
    <title>BonzoMonke Run</title>
    <style>
        canvas { border: 1px solid black; }
        body { 
            margin: 0; 
            background: #000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            overflow: hidden;
            touch-action: manipulation; /* Prevents default touch behaviors */
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            opacity: 0; /* Hidden by default on PC */
            transition: opacity 0.3s;
            pointer-events: none; /* Non-interactive by default */
        }
        .button {
            background: rgba(255, 255, 255, 0.7);
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
        }
        .button:active { background: rgba(255, 255, 255, 0.9); }
        @media (max-width: 800px) {
            canvas { width: 100vw; height: auto; max-height: 100vh; }
            .controls { 
                bottom: 10px; 
                left: 10px; 
                gap: 5px;
                opacity: 1; /* Visible on mobile */
                pointer-events: auto; /* Interactive on mobile */
            }
            .button { 
                padding: 8px 15px; 
                font-size: 14px;
            }
        }
        /* Ensure controls are hidden on PC (large screens with mouse) */
        @media (min-width: 801px) and (hover: hover) {
            .controls { 
                opacity: 0; 
                pointer-events: none; 
            }
        }
        /* Ensure controls are visible on touch devices (small or large) */
        @media (any-pointer: coarse) {
            .controls { 
                opacity: 1; 
                pointer-events: auto; 
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="controls">
        <div class="button" id="up">↑</div>
        <div class="button" id="left">←</div>
        <div class="button" id="right">→</div>
        <div class="button" id="down">↓</div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const controls = document.querySelector('.controls');

        // Load images
        const bonzoImg = new Image();
        const btcImg = new Image();

        // Load sounds
        const coinSound = new Audio('coin.mp3');
        const btcSound = new Audio('btc.mp3');
        const warningSound = new Audio('warning.mp3');
        const bgm = new Audio('bgm.mp3');
        bgm.loop = true;
        bgm.volume = 0.3;
        let isWarningPlaying = false;

        // Game variables
        const CELL_SIZE = 60;
        const GRID_WIDTH = 13; // 800 / 60 ≈ 13 cells wide
        const GRID_HEIGHT = 10; // 600 / 60 = 10 cells tall
        let player = { x: CELL_SIZE, y: CELL_SIZE }; // Start at (1, 1)
        let btc = { x: 0, y: 0 }; // Set later after maze generation
        let coins = [];
        let score = 0;
        let timer = 60;
        let maze = [];

        // Detect device (more robust check)
        let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || 'ontouch' in document.documentElement;

        // Maze generation (recursive backtracking)
        function generateMaze() {
            maze = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(1));

            function carve(x, y) {
                maze[y][x] = 0; // Mark as path
                const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]]; // Up, Right, Down, Left
                directions.sort(() => Math.random() - 0.5); // Shuffle

                for (let [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    if (newX > 0 && newX < GRID_WIDTH - 1 && newY > 0 && newY < GRID_HEIGHT - 1 && maze[newY][newX] === 1) {
                        maze[y + dy / 2][x + dx / 2] = 0; // Carve wall between
                        carve(newX, newY);
                    }
                }
            }

            carve(1, 1); // Start at (1, 1)

            // Place BTC randomly in an open cell
            do {
                btc.x = Math.floor(Math.random() * (GRID_WIDTH - 2) + 1) * CELL_SIZE;
                btc.y = Math.floor(Math.random() * (GRID_HEIGHT - 2) + 1) * CELL_SIZE;
            } while (maze[Math.floor(btc.y / CELL_SIZE)][Math.floor(btc.x / CELL_SIZE)] === 1);

            // Place 3-5 coins randomly
            coins = [];
            const coinCount = Math.floor(Math.random() * 3) + 3; // 3 to 5 coins
            for (let i = 0; i < coinCount; i++) {
                let coinX, coinY;
                do {
                    coinX = Math.floor(Math.random() * (GRID_WIDTH - 2) + 1) * CELL_SIZE;
                    coinY = Math.floor(Math.random() * (GRID_HEIGHT - 2) + 1) * CELL_SIZE;
                } while (maze[Math.floor(coinY / CELL_SIZE)][Math.floor(coinX / CELL_SIZE)] === 1 || 
                         (coinX === btc.x && coinY === btc.y) || 
                         coins.some(c => c.x === coinX && c.y === coinY));
                coins.push({ x: coinX, y: coinY });
            }
        }

        function isWall(x, y) {
            const gridX = Math.floor(x / CELL_SIZE);
            const gridY = Math.floor(y / CELL_SIZE);
            return maze[gridY][gridX] === 1;
        }

        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + CELL_SIZE &&
                   obj1.x + CELL_SIZE > obj2.x &&
                   obj1.y < obj2.y + CELL_SIZE &&
                   obj1.y + CELL_SIZE > obj2.y;
        }

        // Keyboard controls (for PC)
        document.addEventListener('keydown', (e) => {
            if (isTouchDevice) return; // Skip keyboard if on touch device
            let newX = player.x;
            let newY = player.y;
            if (e.key === 'ArrowUp') newY -= CELL_SIZE;
            if (e.key === 'ArrowDown') newY += CELL_SIZE;
            if (e.key === 'ArrowLeft') newX -= CELL_SIZE;
            if (e.key === 'ArrowRight') newX += CELL_SIZE;
            if (!isWall(newX, newY)) {
                player.x = newX;
                player.y = newY;
            }
        });

        // Touch controls (for mobile)
        const controls = {
            up: document.getElementById('up'),
            left: document.getElementById('left'),
            right: document.getElementById('right'),
            down: document.getElementById('down')
        };

        Object.values(controls).forEach(button => {
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!isTouchDevice) return; // Skip touch if not on touch device
                const move = button.id;
                let newX = player.x;
                let newY = player.y;
                if (move === 'up') newY -= CELL_SIZE;
                if (move === 'down') newY += CELL_SIZE;
                if (move === 'left') newX -= CELL_SIZE;
                if (move === 'right') newX += CELL_SIZE;
                if (!isWall(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            });
            button.addEventListener('click', (e) => {
                e.preventDefault();
                if (!isTouchDevice) return; // Skip click if not on touch device
                const move = button.id;
                let newX = player.x;
                let newY = player.y;
                if (move === 'up') newY -= CELL_SIZE;
                if (move === 'down') newY += CELL_SIZE;
                if (move === 'left') newX -= CELL_SIZE;
                if (move === 'right') newX += CELL_SIZE;
                if (!isWall(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            });
        });

        // Game loop
        function gameLoop() {
            timer -= 1 / 60;
            if (timer <= 0) {
                bgm.pause();
                return; // Game over
            }

            if (checkCollision(player, btc)) {
                score += 500;
                btcSound.play();
                do {
                    btc.x = Math.floor(Math.random() * (GRID_WIDTH - 2) + 1) * CELL_SIZE;
                    btc.y = Math.floor(Math.random() * (GRID_HEIGHT - 2) + 1) * CELL_SIZE;
                } while (isWall(btc.x, btc.y));
            }

            coins = coins.filter(coin => {
                if (checkCollision(player, coin)) {
                    score += 10;
                    timer += 5;
                    coinSound.play();
                    return false;
                }
                return true;
            });

            if (timer <= 10 && !isWarningPlaying) {
                warningSound.play();
                isWarningPlaying = true;
            } else if (timer > 10 && isWarningPlaying) {
                warningSound.pause();
                warningSound.currentTime = 0;
                isWarningPlaying = false;
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, 800, 600);

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#666';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }

            ctx.fillStyle = '#ff0';
            coins.forEach(coin => {
                ctx.beginPath();
                ctx.arc(coin.x + CELL_SIZE / 2, coin.y + CELL_SIZE / 2, 15, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw BTC and player only if images are loaded
            if (bonzoImg.complete && btcImg.complete) {
                ctx.drawImage(btcImg, btc.x, btc.y, CELL_SIZE, CELL_SIZE);
                ctx.drawImage(bonzoImg, player.x, player.y, CELL_SIZE, CELL_SIZE);
            }

            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.fillText(`Time: ${Math.floor(timer)}`, 10, 30);
            ctx.fillText(`Score: ${score}`, 10, 60);

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            generateMaze();
            player = { x: CELL_SIZE, y: CELL_SIZE };
            score = 0;
            timer = 60;
            isWarningPlaying = false;
            bgm.play();

            // Adjust controls visibility based on device
            if (isTouchDevice) {
                controls.style.opacity = 1;
                controls.style.pointerEvents = 'auto';
            } else {
                controls.style.opacity = 0;
                controls.style.pointerEvents = 'none';
            }
            gameLoop();
        }

        // Set image sources and start game when loaded
        bonzoImg.onload = btcImg.onload = () => startGame();
        bonzoImg.onerror = () => console.error('Failed to load bonzo_monke.png');
        bonzoImg.src = 'bonzo_monke.png';
        btcImg.onerror = () => console.error('Failed to load btc_logo.png');
        btcImg.src = 'btc_logo.png';
    </script>
</body>
</html>
